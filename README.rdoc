== README

This README would normally document whatever steps are necessary to get the
application up and running.

Things you may want to cover:

* Ruby version

* System dependencies

* Configuration

* Database creation

* Database initialization

* How to run the test suite

* Services (job queues, cache servers, search engines, etc.)

* Deployment instructions

* ...


Please feel free to use a different markup language if you do not plan to run
<tt>rake doc:app</tt>.

2.10 Demonstracja Rails, budowanie ksiegi gosci, cz. 2 viedopoint
2.11 Bonus: sztuczka z edytorem
3. Modele
3.6
3.7 Callbacki
3.8 Scopes - to nic innego jak nazwana kwerenda

3.9 Asocjacja belongs_to i has_many
3.10 Asocjacaja has_and_belongs_to_many - czyli przypisanie wiele do wielu (robimy to za pomoca tabeli posredniej
    - ktora przechowuje pojedyncze przypisanie taga do posta)
3.11 Asocjacja has_many :through

     http://guides.rubyonrails.org/association_basics.html#the-has-many-through-association

3.12 Kwerendy na asocjacjach
4. Kontrollery
4.3 Akcja Index
4.4 Akcja New for formularz


5.5 Ukrywanie JavaScript i CoffeeScript
   - Uzyciek coffee scriptu jest o wiele prostsze, nie trzeba pisac tyle linijek kodu i jest przyjemniejszy

   index
   <% @posts.each do |post| %>
       <blockquote>
         <p><%= post.body %></p>
         <foother><cite><%= post.author %></cite></foother>
       </blockquote>
   <% end %>



   hide.coffee
   $ ->
     $(".container blockquote").on "click", ->
       $(this).hide(400)

   hide.js
   $(function() {
       $(".container blockquote").on("click", function () {
           $(this).hide(300);
       })
   })


5.6 Ajax: linki asynchroniczne

    1.Najpierw scieżki
      resources :posts do
        collection do
          get :surprise
        end
      end


    2.Akcja w kontrolerze
     def surprise
     end

    3. Klasa w widoku posts (bardzo wazne: remote:true) w tej klasie bedzie sie duzo dziac
      <div id="content-placeholder">
          <%= link_to "Niespodzianka", surprise_posts_path, class: "btn btn-info", remote: true %>
      </div>

    4. Nowy katalog z ajaxem w views/posts:  surprise.js.erb

       $("#content-placeholder").html("<%= escape_javascript(render(partial: "surprise_content")) %>");


    5. Prashal takze w views : _surprise_content.html.erb
       <div class="jumbotron">
         <h1>Niespodzianka?</h1>
         <p> To jest fajna niespodzianka </p>
         <p><%= link_to "Sprawdz to", posts_path, class: "btn btn-lg btn-primary" %></p>
       </div>

5.7  Ajax: formularze asynchroniczne
     1. Na początek musimy dodac id (id="form-container) : w views/posts/new
        w której bedzie sie duzo dzialo i BARZO WAZNE dodajemy metode remote: true - to dzięki niej mamy żadanie asynchroniczne

        <div id="form-container">
          <%= form_for @post, remote: true do |f| %>
              <div class="form-group">
                <%= f.label :athour, "Autor" %>
                <%= f.text_field :author, class: "form-control" %>
              </div>
              <div class="form-group">
                <%= f.label :body, "Tresc" %>
                <%= f.text_field :body, class: "form-control" %>
              </div>
              <%= f.submit "Dodaj wpis", class: "btn btn-default" %>
          <% end %>
        </div>

     2. W kontrolerze musimy dodac format danych ( uzytkownik moze miec wylączony js w przegladarce) a tak to niweluje ta zmiane
          def create
              @post = Post.new(post_params)
              if @post.save
                respond_to do |format|
                  format.html do
                    flash[:notice] = "Dziekujemy za wpis"
                    redirect_to posts_path
                  end
                  format.js {}
                end
              end
            end

     3. Nastepnie tworzymy plik w views.posts/create.js.erb
            $("#form-container").hide(500, function() {
              $("#form-container").html("<div class=\"alert alert-success\">Dziekujemy za wpis!</p>");
              $("#form-container").show(500);
            })


5.8 Turbolinks
     Jest automatycznie wczytywany i uzywany
     ale mozna go wylaczyc :
     <a href="/posts" data-no-turbolink> Ten link nie ma turbolinks</a>


6. Pisanie automatycznych testow - Test to nic innego jak kod ktory wywoluje inny kod i ktory spr. czy jest zgodny z oczekiwaniami
6.2 Testowanie modeli
     Mamy taką metode w modelu Post
      private
       def titleize_author
        self.author = self.author.to_s.titleize
       end

6.3 Testowanie kontrolerow
    class PostsControllerTest < ActionController::TestCase
      test "should get index" do
        get :index
        assert_response :success
        assert_not_nil assigns(:posts)
      end

      test "should get new" do
        get :new
        assert_response :success
        assert_not_nil assigns(:post)
      end

      test "should create a post" do

        assert_difference -> { Post.count}, 1 do
          post :create, post: {author: "Autor", body: "Wpis"}
        end


        assert_redirected_to posts_path
      end
    end

6.4 Capybara: testy integracyjne
    Mamy bardzo fajnego pomocnika https://github.com/teamcapybara/capybara
    postepujemy zgodnie z instrukcja dla test_unit
      - dodajemy gem
      - instalujemy
      - plik konfiguracyjny

     do /test_helper
     require 'capybara/rails'


      - nowy test tworzymy test/integration/guest_book.test.rb

           class GuestBookTest < ActionDispatch::IntegrationTest
             setup do
             end

             test "creates a post" do
               visit posts_path
               click_link "Dodaj wlsny wpis juz teraz"
               fill_in "Autor", with: "Testowy Autor"
               fill_in "Tresc", with: "Testowa treść"
               click_button "Dodaj wpis"

               assert page.has_content?("Dziękujemy za wpis"), "expected a flash message"
               assert page.has_content?("Testowy Author")
               assert page.has_content?("Testowa treść")
             end
           end

6.5 Spring: szybkie uruchamianie Rails i testow   - dzieki temu nie musi byc uruchaminana cala apka od nowa leczy tylko same testy
    spring

    bin/rake test     - tak uruchamiamy testy/ wszystko z bin bedzie nam szybko wczytywac ale dopiero durgi raz
    spring status
    spring stop
    bin/rake test


7. Wysylanie e-maili
   * rails g mailer PostsMailer new_post_notification
       Mozemy podejrzec mailera:
         * http://localhost:3000/rails/mailers
   http://localhost:3000/rails/mailers/posts_mailer/new_post_notification

   w /mailer/posts_mailer.rb

   class PostsMailer < ApplicationMailer

     # Subject can be set in your I18n file at config/locales/en.yml
     # with the following lookup:
     #
     #   en.posts_mailer.new_post_notification.subject
     #
     def new_post_notification(post)
       @post = post

       mail to: "to@example.org", subject: "Wow, nowy post!"
     end
   end


 zmieniamy takze widoki w mailerze
 oraz na sztywno damy mu dane chwilowo w :
 spec/mailers/previews/posts_mailer_prewiew.rb

 - wypelniamy pola ktore wyswietla sie podgladzei

 def new_post_notification
     PostsMailer.new_post_notification(Post.new(author: "Jhon", body: "Czesc wszytkim"))
 end


i tu sobie podglądamy maila : http://localhost:3000/rails/mailers/posts_mailer/new_post_notification





7.2 Wysylanie e-maila   - uzyjemy gemu letter_opener  - on bedzie oszukiwal ze
        wysla poczte z serwera tylko lokalnie bedzie nam to pokazywal w przeglądarce
        podlanczamy po prostu falszywą metode wysylania emaili

        
    CHCEMY  zeby na mail wysylal sie za kazdym razem
    dodamy callbecka i metode  - ale to nie bedzie nam wysylac maila

    zrobimy to w:    app/models/post.rb

      after_create :notify_admin

      def notify_admin
        PostsMailer.create_new_post_notification(self).deliver    -sama metoda deliver nie wysle go musimy uzyc serwera
      end
  * Musimy teraz skonfigurowac srodowisko developerskie do wysylania mailera
    w:
    config/development.rb

    - wkleimy gotowa konfiguracje

     config.action_mailer.delivery_method = :letter_opener
      config.action_mailer.smtp_settings = {
        :address              => "smtp.gmail.com",
        :port                 => 587,
        :user_name            => 'twojemail@gmail.com',
        :password             => 'abcdefg',
        :authentication       => "plain",
        :enable_starttls_auto => true                       - tutaj wlaczamy polaczenie szyfrowane
        }
      config.action_mailer.default_url_options = { :host => "localhost:3000" }    - bardzo wazne
         - maile nie sa renderowanae w przegladarce tylko w programie pocztowym i porgam pocztowy nie wie
           z ktorej domenty zostala wyslana wiadoamosc i dzieki tem railsy wiedza z jakiego hosta zostala
           wyslana ta wiadomosc

        config.action_mailer.raise_delivery_errors = false      # tu mamy opcje dzieki ktorej wylanczamym dostarzczanie informacji o bledach ale my ja wlczmy
        config.action_mailer.raise_delivery_errors = true


  * gdy wjedziemy na:    app/mailers/post_mailer.rb
       - widzimy ze standardowy wpis to to@example.org ale my to zmienimy na:


       def new_post_notification(post)
           @post = post
           mail to: "pikowoko@gmail.com", subject: "Wow, nowy post!", from: 'Hello Rails <pikowoko@gmail.com>'
       end

  * dodalem takze gem letter_opener  - zeby dzialalo wysylanie wiadomosci w nowycgh railsach
      group :development do
        # Access an IRB console on exception pages or by using <%= console %> in views
        gem 'web-console', '~> 2.0'
     -> gem 'letter_opener'

        # Spring speeds up development by keeping your application running in the background. Read more: https://github.com/rails/spring
        gem 'spring'
      end

7.3 Udawane wysylanie emaila






